### 정점과 간선

정점 - 간선
ex.
위치 - 경로
사람 - 관계

간선

- 단방향 간선
- 양방향 간선

### outdegree, indegree

u : from , v : to

u의 입장에서
outdegree : u에서 v까지 갈 수 있는 간선의 개수
indegree : v에서 u로 들어오는 간선의 개수

### 가중치

가중치 : 간선에 대한 비용

### 트리

## 트리문제는 루트노드부터 시작해서 DFS든 BFS든 돌리면 쉽게 풀리는 문제가 많다.

### 이진트리

## 모든 노드의 자식노드가 2개 이하인 트리

# degenerate(변질이진트리) : 자식노드가 하나밖에 없는거

## balanced(균형이진트리) : 왼쪽과 오른쪽의 높이 차이가 1 이하인 트리입니다.

- 레드블랙트리 : 맵, 셋을 구성한다.

### 이진탐색트리

왼쪽에는 작은거, 오른쪽에는 큰게 들어있는 트리

- 만약 균형이진트리라면 시간복잡도 : O(logN)

만드는 경우 1, 2, 3 이 순서대로 들어가면 선형적인 형태가 나타나게 됨.

- O(N)의 복잡도가 나타나게 된다.

그래서 삽입순서가 어떻든 트리의 노드를 회전시키는 방법을 통해 균형잡히게 만들어버리는

- AVL트리, 레드블랙트리
  map은 레드블랙트리를 기반으로 구현.
  삽입, 탐색, 삭제, 수정이 logN의 시간복잡도를 가지는 이유.

### 인접 행렬

## 위와같은 정점과 간선을 컴퓨터에게 어떻게 알려줄까?

# 2차원 배열을 기반으로 그래프 표현은

# 인접행렬 이용!

- 인접행렬이란 무엇인가?
  0 정점과 간선을 나타내는 bool타입의 정사각형 행렬입니다.
  이 행렬은 0과 1의 요소로 이루어져 있고 0은 두 정점 사이 경로가 없음을, 1은 두 정점 사이 경로가 있음을 의미합니다.

직접 연결되어 있으면 1을 삽입.

[0][1] : 0에서 1까지.
0 1 2 3
1  
2  
3

단방향 간선
양방향 간선(=무방향 간선)

### 인접 리스트

## 연결리스트 여러개 사용하여 그래프 표현

1. 각 정점마다 연결되어 있는 정점으로 구성된 연결리스트를 만들자.

구현은 리스트가 아니라 vector로 구현하자.
vector<int> adj[V];

벡터가 V개 있는 것임.
삽입, 삭제는 O(1)이지만 탐색, 참조를 순차적으로 해야하기 때문에 O(n)이라는 시간복잡도가 걸린다.
반면 벡터는 n번째 요소를 참조한다고 할 때 O(1)이라는 시간복잡도가 걸린다.

### 인접행렬 vs 연결리스트

## 공간 복잡도

# 인접행렬 O(V^2) 연결리스트 O(V+E)

## 시간 복잡도

# 하나의 간선을 찾는 경우

- 인접행렬 : O(1)
- 인접리스트: O(V)

# 모든 간선을 찾는 경우

- 인접행렬 : O(V^2)
- 인접리스트 : O(V + E);

그래프가 희소한 경우 : 인접리스트 사용
그래프가 조밀한 경우 : 인접행렬이 더 좋음.

결론 : 보통은 인접리스트를 사용하면 됨. sparse(희소)한 그래프가 주로 나오기 때문임.

그래도 면접이나 코테에서 많이 나오기 때문에 둘 다 알아야 하긴 함.

### 문제에서 맵으로 주어지는 경우 그래프

문제에서 맵으로 주어지면 인접리스트나 인접행렬로 바꾸지 말고 맵으로 풀어야함.

# 상하좌우 탐색하기

1. dy와 dx 배열을 만든다.
2. dy와 dx를 사용하여
   (y-1, x)

(y,x-1)(y, x)(y,x+1)
(y+1,x)

dy = [-1,0,1,0]
dx = [0,1,0,-1]
for(int i=0 ;i<4;i++){
ny = y+dy[i]
nx = x+dx[i]
}

if (ny<0 || ny>=n || nx<0 || nx>=n) continue;
-> 언더플로우, 오버플로우 나지 않게 하는 조건문

### 연결된 컴포넌트 (connected component)

연결된 하나의 덩어리라고 생각하면 된다.
연결된 텀포넌트에 속한 모든 정점은 열결되는 경로가 있다.

### DFS 깊이우선탐색

- 그래프를 탐색할 때 사용하는 알고리즘.
- 인접 노드들을 **재귀적으로 방문**하며 방문한 정점은 다시 방문하지 않는다.
- 각 분기마다 가능한 멀리까지 있는 노드를 탐색

#코드

## 구현방법 1 돌다리 두드리기!

- 방문되지 않은 정점만 방문하기
  void dfs(int u){
  cout << u;
  visited[u]=1;
  for(int i : adj[u]){
  if (visited[u]) continue;
  dfs(i);
  }
  }

## 구현방법 2 못먹어도 고!

- if 사용하여 return으로 구현하기.
  void dfs(int here){
  if(visited[here]) return;
  for(int there:adj[here]){
  dfs[there];
  }
  }

### BFS 너비우선탐색

- 그래프 탐색 시 사용하는 알고리즘
- 현재 깊이의 모든 정점 탐색하며 방문한 정점 다시 방문하지 않음.
- 같은 가중치 가진 그래프에서 최단거리에 사용된다.
- visited배열은 최단거리를 담는 배열로도 사용된다.
- **재귀를 사용하지 않고 큐**를 사용하자.

# 큐를 이용하자!

- 선입선출 (화장실 줄서기)

# 무조건 시작 지점에는 visited[here] = 1;을 걸어주도록 하자.

# 안걸게 되면 양방향 간선인 경우 첫번째 노드에 대한 로직이 또 들어가야 함.

# 코드

void bfs(int here){
queue<int> q;
q.push(here);
visited[here] = 1;
while(q.size()){
int here = q.front();
q.pop();
for(int there : adj[here]){
if(visited[there]) continue;
visited[there] = visited[here]+1;
q.push(there);
}
}
}

## DFS vs BFS

# 시간복잡도 동일

인접리스트 O(V+E) 인접행렬 O(V^2)
DFS : 메모리 덜씀. 그래프 탐색의 경우 사용
BFS : 메모리를 더 씀(큐가 있으니까). 최단거리 구하는데 사용

### 트리 순회

## 후위순회 (postorder)

- 자신을 자식들 이후에 탐색한다.

## 전위순회 (preorder)

- 자신을 자식들 이전에 탐색한다. -> DFS

## 중위순회 (inorder)

- 자신을 자식들 사이에 탐색한다.

## 레벨순회

- BFS

### 맞왜틀!

# 1. 반례를 생각하자!

- 최대, 최소값
- 있는가 없는가.

# 2. 변수명을 통일하자. ex) dy, dx, ny, nx, cnt, res...

### 분할정복

- 재귀 혹은 스택을 사용할 수 있다.
- 재귀를 사용하는 경우 return을 잘 사용하자.

### sort()

bool cmp (int a, int b){
return a < b
}
-> a가 b보다 작을 때 우선적으로 정렬을 수행한다.
-> 더 작은 값이 앞으로 가게 되는 것임.

return a > b 이면
-> a가 b보다 클때 정렬을 수행하므로 더 큰 값이 앞으로 간다.


### prev이용한 연속 값 비교
prev = i 라고 할당하여 사용하기.

### string 타입 숫자 비교
아스키 코드는 숫자의 크기를 따라가기 때문에 
a = 1, b = 2  인 경우 아스키 코드도 a < b  == true 임.

return a < b 를 통해 오름차순 정렬을 수행할 수 있음.

if (a<65) -> a가 숫자라면

### string 포함 여부
js에서 include 함수는 C++에서 find로 대체할 수 있음.
if(string.find(찾을거)!=string::npos) -> 존재한다면